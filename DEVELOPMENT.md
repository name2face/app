# Name2Face App - Development TODO

This document tracks the development progress of the Name2Face app, based on the [Specification Document (Draft)](link/to/your/spec/document.md).

**Backend Technology:** Supabase (PostgreSQL Database, APIs) will be used as the primary data store instead of purely local SQLite. This provides a solid foundation for future features like multi-device sync, while V1 will focus on core functionality using this backend.

**Current Status:** Setting up the project and defining the data model in Supabase.

---

## 🎯 Overall Goals for V1

*   Implement core features: Add Person, Add Details, Edit, Delete, Search, View Details.
*   Store all person data reliably in Supabase.
*   Provide the specified UI/UX, including navigation and loading states.
*   Meet non-functional requirements (performance, offline capability - **clarification needed for V1 scope**, persistence).

---

## ✅ Technical Foundation

*   [x] Confirm Platform Targets: iOS, Android
*   [x] Confirm Framework: React Native
*   [x] Confirm Development Environment: Expo (Managed Workflow)
*   [x] Confirm Language: TypeScript
*   [x] Confirm Navigation Library: React Navigation
*   [x] Confirm Styling: React Native `StyleSheet` API
*   [x] **DECISION:** Use **Supabase** for the primary data store.
    *   Supabase will handle the database (PostgreSQL), APIs, and potentially file storage later (V2 for photos).
    *   This impacts data modeling (PostgreSQL tables), data access (Supabase JS client), and search implementation (PostgreSQL search capabilities).
    *   **ACTION/CLARIFICATION NEEDED (V1 Offline Requirement):** The spec requires *full* offline capability for V1. Pure Supabase is online. Using Supabase *and* being fully offline in V1 requires a local database cache and synchronization logic (significant complexity). **Need to confirm with [Friend's Name] if V1 MUST be fully offline.**
        *   *Option A (Simpler V1):* Make V1 primarily online-only using Supabase. If offline, user can view previously loaded data but cannot add/edit/search until online. (Defer full sync for V2).
        *   *Option B (Complex V1):* Implement a local database (like `expo-sqlite` or WatermelonDB) as a cache layer synced with Supabase. (Adds significant development time).
        *   *Initial Plan (assuming Option A for scope):* Build V1 primarily online using Supabase. If offline is *critical* for V1, we revisit scope or timeline.
*   [ ] Choose initial State Management: Start with React's built-in state (`useState`) and Context API (`useContext`).

---

## 🚧 Development Phases & Tasks

### Phase 0: Project Setup & Supabase Integration

*   [ ] Create new Expo/React Native project with TypeScript template.
*   [ ] Install necessary dependencies (`react-navigation`, `@supabase/supabase-js`, etc.).
*   [ ] Create a new project in Supabase.
*   [ ] Configure environment variables in the Expo app to connect to Supabase (API URL, anon key).
*   [ ] **Define Supabase Data Model:**
    *   [ ] Create `persons` table:
        *   `id`: `uuid` (Primary Key, auto-generated by Supabase)
        *   `name`: `text` (NOT NULL)
        *   `memory_hooks`: `text`
        *   `gender`: `text` (e.g., 'Female', 'Male', 'Other', or NULL)
        *   `created_at`: `timestamp with time zone` (Default: `now()`)
        *   `updated_at`: `timestamp with time zone` (Default: `now()`, Trigger: `ON UPDATE SET updated_at`)
    *   [ ] Create `tags` table:
        *   `id`: `uuid` (Primary Key, auto-generated) or `text` (if tags are just the string value and unique) - `text` might be simpler if tags are global strings. Let's go with `text` as the PK for simplicity in V1 tag management.
        *   `tag_name`: `text` (Primary Key, Unique, NOT NULL) - Use `tag_name` as the ID.
    *   [ ] Create `person_tags` join table (Many-to-Many relationship):
        *   `person_id`: `uuid` (Foreign Key to `persons.id`)
        *   `tag_name`: `text` (Foreign Key to `tags.tag_name`)
        *   `created_at`: `timestamp with time zone` (Default: `now()`)
        *   Composite Primary Key: `(person_id, tag_name)`
    *   [ ] Implement basic Row Level Security (RLS) policies for `persons`, `tags`, `person_tags` (e.g., `SELECT` and `INSERT` for authenticated/anon users if no auth V1, or based on user ID if auth is added).
*   [ ] Set up Supabase client instance in the app.

### Phase 1: Basic Data Layer (CRUD)

*   [ ] Write helper functions in the app to interact with Supabase:
    *   `createPerson(name, details?)`: Inserts into `persons`, handles tags via `person_tags`.
    *   `updatePerson(id, updates)`: Updates `persons` row by ID, handles tag updates (add/remove from `person_tags`).
    *   `deletePerson(id)`: Deletes row from `persons` (Supabase Foreign Key cascade should handle `person_tags`).
    *   `getPersonById(id)`: Fetches person data by ID, including related tags via join.
    *   `searchPersons(query)`: (Implement in Phase 3)

### Phase 2: Add Person & Add Details Flow

*   [ ] Create `Home Screen` component with the two primary buttons (`New Name to Face`, `Recall Name to Face`) using the specified icon concepts.
*   [ ] Implement navigation from `Home Screen` buttons using React Navigation.
*   [ ] Create `Add Person Screen` component:
    *   [ ] Name input field.
    *   [ ] `Save` and `Add Details` buttons (initially disabled).
    *   [ ] Enable buttons when name input is non-empty (after trim).
    *   [ ] Implement `Save` button logic:
        *   [ ] Show loading feedback (spinning plus icon).
        *   [ ] Perform case-insensitive duplicate name check against Supabase (`SELECT EXISTS(...)`).
        *   [ ] If no duplicate: Call `createPerson({ name: trimmedName })`.
        *   [ ] If duplicate: Show "Duplicate Name" dialog.
        *   [ ] Handle dialog actions (`Add Details`, `Save Anyway`, `Cancel`).
        *   [ ] On successful save/save anyway: Navigate to `Home Screen`.
    *   [ ] Implement `Add Details` button logic:
        *   [ ] Navigate to `Add Details Screen` passing the name.
*   [ ] Create (or design for reuse as) `Add/Edit Details Screen` component:
    *   [ ] Receive name (and potentially ID if editing) as navigation params.
    *   [ ] Name input (pre-filled if editing, potentially editable).
    *   [ ] Memory Hooks text area.
    *   [ ] Quick Tags display/interaction (add/remove tags locally in state).
    *   [ ] Custom Tags input and display (add/remove tags locally in state).
    *   [ ] Gender selection (Picker/Dropdown).
    *   [ ] `Save` button (initially Add flow):
        *   [ ] Show loading feedback (spinning plus icon).
        *   [ ] Validate name is not empty.
        *   [ ] Perform case-insensitive duplicate name check against Supabase *if* name was changed or if coming from `Add Person`'s `Add Details` path after a duplicate was found.
        *   [ ] If no duplicate or `Save Anyway` from dialog: Call `createPerson(...)` with all details (name, hooks, tags, gender). This involves inserting into `persons` and then inserting rows into `person_tags` for each selected tag.
        *   [ ] Navigate to `Person Detail Screen` for the newly created person.
    *   [ ] `Cancel` button (Add flow):
        *   [ ] Show confirmation dialog ("Discard this new entry?").
        *   [ ] If confirmed: Navigate back to `Home Screen`.
    *   [ ] `Delete` button: (Implement and make visible/active only in Edit flow - see Phase 4)

### Phase 3: Search & View Results Flow

*   [ ] Create `Search Query Screen` component:
    *   [ ] Input fields for Name, Memory Hooks, Tags.
    *   [ ] Gender filter (Picker/Dropdown).
    *   [ ] `Search` button (initially enabled).
    *   [ ] Implement `Search` button logic:
        *   [ ] Show loading feedback (spinning question mark icon), disable button.
        *   [ ] Call `searchPersons(query)` function.
        *   [ ] Navigate to `Search Results Screen` passing the results.
*   [ ] Implement `searchPersons(query)` function using Supabase/PostgreSQL:
    *   [ ] Construct a single SQL query that combines filtering criteria:
        *   `ILIKE` for case-insensitive name search.
        *   PostgreSQL Full-Text Search (`tsvector`, `tsquery`) for `memory_hooks`.
        *   Join with `person_tags` table to filter by selected tags.
        *   Equality filter for `gender`.
    *   [ ] **Implement Relevance Scoring:** Define and apply a simple scoring logic within the SQL query or in app logic after fetching to order results (Name match highest score, then Tags, then Hooks).
    *   [ ] Fetch combined results from Supabase.
*   [ ] Create `Search Results Screen` component:
    *   [ ] Display list of results received from `searchPersons`.
    *   [ ] Use `Card` layout as specified: prominent name, context snippet (matched tag or memory hook snippet).
    *   [ ] Implement logic to extract a relevant snippet from `memory_hooks` for the card display based on the search keywords.
    *   [ ] Display "No matches found" message if results list is empty.
    *   [ ] Implement tapping a card to navigate to `Person Detail Screen` passing the person's ID.

### Phase 4: View & Edit Person Flow

*   [ ] Create `Person Detail Screen` component:
    *   [ ] Fetch person data using `getPersonById` based on ID from navigation params.
    *   [ ] Display Name prominently.
    *   [ ] Conditionally display Tags (as chips/badges) if they exist.
    *   [ ] Conditionally display Gender if specified (not null, not "Prefer not to specify").
    *   [ ] Display `createdAt` date.
    *   [ ] Conditionally display Memory Hooks text if it exists.
    *   [ ] Add an `Edit` button in the screen header.
    *   [ ] Implement `Edit` button logic: Navigate to `Edit Details Screen` passing the person's ID.
*   [ ] Enhance (or reuse) `Add/Edit Details Screen` to handle the Edit flow:
    *   [ ] When an ID is passed via navigation, fetch existing person data and pre-populate all fields.
    *   [ ] Change screen title (e.g., "Edit Details for [Name]").
    *   [ ] Update `Save` button logic (Edit flow):
        *   [ ] Show loading feedback (spinning plus icon).
        *   [ ] Validate name.
        *   [ ] Perform case-insensitive duplicate name check against *other* people in Supabase (`SELECT EXISTS(...) WHERE name = ? AND id != ?`).
        *   [ ] If no duplicate or `Save Anyway`: Call `updatePerson(id, updates)` with all modified details. This involves updating the `persons` row and syncing `person_tags` (deleting old, inserting new as needed).
        *   [ ] Navigate back to `Person Detail Screen` for the edited person.
    *   [ ] Update `Cancel` button logic (Edit flow):
        *   [ ] Discard local changes. Navigate back to `Person Detail Screen`.
    *   [ ] Make the `Delete` button visible and active (Edit flow):
        *   [ ] Implement `Delete` button logic:
            *   [ ] Show confirmation dialog ("Delete [Person's Name]?").
            *   [ ] If confirmed: Call `deletePerson(id)`.
            *   [ ] Navigate back to `Home Screen` after successful deletion.

### Phase 5: UI Polish & UX Refinements

*   [ ] Implement consistent validation feedback UI (e.g., error messages, input highlighting).
*   [ ] Refine layout and styling based on spec concepts (e.g., Home screen button styles, card appearance).
*   [ ] Ensure all specified loading indicators and disabled button states are correctly implemented during async operations.
*   [ ] Review all confirmation dialogs and ensure messaging is clear.
*   [ ] Test input trimming logic (leading/trailing whitespace) on all relevant input fields before processing/saving.
*   [ ] Test edge cases (e.g., very long memory hooks, many tags, special characters in names/tags).
*   [ ] Add basic accessibility considerations (labels, contrasts).

### Phase 6: Testing & Release Preparation

*   [ ] Perform comprehensive testing on target devices (iOS, Android).
*   [ ] Test all user flows (add quick, add detailed, search happy path, search no results, view, edit, delete).
*   [ ] Test duplicate name scenarios in both add and edit flows.
*   [ ] Verify data persistence between app sessions.
*   [ ] (Depending on V1 Offline Decision) Test offline behavior and recovery when online.
*   [ ] Prepare for Expo build (icons, splash screen, app.json configuration).

---

## 🔧 Technical Notes & Decisions

*   **Data Storage:** Supabase (PostgreSQL) is the backend.
*   **Tags:** Stored in a many-to-many relationship using `person_tags` join table in Supabase.
*   **Search:** Will leverage PostgreSQL's `ILIKE` for name, Full-Text Search (FTS) capabilities for `memory_hooks`, and joins for `tags`. Relevance scoring will be implemented in the query or app.
*   **Offline:** V1 scope is currently planned as primarily online with Supabase. **Needs confirmation if full offline V1 is required.** Implementing full offline sync is a significant V2 task or requires adjusting the V1 timeline/scope.
*   **Relevance Scoring Algorithm:** *[Define Simple Algorithm Here, e.g., using PostgreSQL's FTS ranking + custom scoring for name/tags.]*
    *   Example (Simple): `score = (name_match ? 3 : 0) + (tag_matches.count * 2) + (hooks_fts_rank > 0 ? 1 : 0)` - Order by `score DESC`. (This is a starting point, actual SQL ranking functions are better).

---

## ❓ Open Questions for [Friend's Name]

*   **V1 Offline Capability:** Is it strictly required that V1 works fully offline (adding, editing, searching)? Or is it acceptable for V1 to require an internet connection for most operations, while offline viewing of previously loaded data is a nice-to-have (Option A above)? Implementing full offline sync (Option B) adds significant complexity and time to V1.
*   Are the Home Screen button/icon concepts (spinning plus/question mark) something you'd like custom assets for, or can we use standard UI elements styled similarly?
*   Any strong preferences on the "Quick Tags" suggestions provided in the spec?

---

## ✨ Future Considerations (V2+)

*   Add Photos (`photoUri` field).
*   Import/Export data.
*   Reminders/Follow-ups.
*   Sync across devices (if not fully implemented in V1).
*   Grouping/Events.
*   Advanced Search/Filter options on Results screen.
*   Settings Screen.
*   Data Backup/Restore mechanism (Supabase handles backend backups, but client export/import might be needed).
*   Dedicated input fields for structured details (Birthdays, Company, etc.).
*   User Authentication/Accounts (if multiple users need separate data).

---
